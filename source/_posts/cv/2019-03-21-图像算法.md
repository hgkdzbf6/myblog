---
layout: post
title:  "å›¾åƒç®—æ³•"
date:   2019-03-21 22:30:07 +0800
categories: Python
---

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

## ä¸ºä»€ä¹ˆå†™è¿™ç¯‡æ–‡ç« ï¼Ÿ

å›¾åƒçš„ç®—æ³•å› ä¸ºopencvå½“ä¸­å·²ç»é›†æˆäº†å¾ˆå¤šï¼Œç°åœ¨å†™ä¸€äº›ï¼Œè™½ç„¶å¾ˆç®€å•çš„ç®—æ³•ã€‚æœ‰çš„æ—¶å€™é¢è¯•ä¹Ÿä¼šé—®åˆ°çš„å“¦ğŸ˜¿

### åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨çŸ©å½¢å½“ä¸­ã€‚

è®¾çŸ©å½¢$$ABCD$$ï¼Œå’Œç‚¹$$P$$ã€‚

åªè¦è®¡ç®—$$(\vec{AB} \times \vec{AP} ) * (\vec{CD} \times \vec{CA})  \ge 0$$å’Œ$$(\vec{AD} \times \vec{AP} ) * (\vec{BC} \times \vec{BA})  \ge 0$$å³å¯ã€‚

è¯´å°±è¯´æ˜¯åˆ¤æ–­ç‚¹åœ¨ä¸åœ¨ä¸¤æ¡çº¿æ®µä¹‹é—´å¤¹ç€ã€‚

ä»£ç å¦‚ä¸‹ï¼š

{% codeblock lang:python %}

{% endcodeblock %}

### cannyç®—å­

åŸºæœ¬åŸç†ï¼šæ£€æµ‹äº®åº¦çš„æ€¥å‰§å˜åŒ–ï¼ˆå¤§æ¢¯åº¦ï¼Œæ¯”å¦‚ä»é»‘è‰²å˜æˆç™½è‰²é…±ï¼‰ï¼Œç„¶åç»™å®šé˜ˆå€¼ï¼Œå®šä¹‰ä¸ºè¾¹ã€‚
é¢„å¤„ç†ï¼šè½¬åŒ–ä¸ºç°åº¦å›¾
1. é™å™ªï¼šå™ªå£°å®¹æ˜“è¯¯æ£€æµ‹ï¼Œç”¨`5x5`çš„é«˜æ–¯æ»¤æ³¢å™¨æ¥å¯¹å›¾åƒè¿›è¡Œå·ç§¯ï¼Œå…¶å®cannyè‡ªå¸¦çš„
2. æ±‚äº®åº¦æ¢¯åº¦ï¼šåœ¨å¹³æ»‘åçš„å›¾åƒä¸Šä½¿ç”¨Sobel Robert Prewittæ ¸ï¼Œæ²¿ç€xï¼Œyå’Œå¯¹è§’çº¿æ£€éªŒè¾¹ç¼˜ã€‚
3. éæå¤§å€¼æŠ‘åˆ¶ã€‚ç»†åŒ–è¾¹ç¼˜ã€‚æ£€æŸ¥æ¯ä¸ªåƒç´ å€¼åœ¨ä¹‹å‰è®¡ç®—çš„æ¢¯åº¦æ–¹å‘ä¸Šæ˜¯ä¸æ˜¯å±€éƒ¨æœ€å¤§å€¼ã€‚å¦‚æœä¸æ˜¯æå¤§å€¼çš„è¯å°±æŠŠè¿™ä¸ªå€¼å»æ‰ã€‚
4. hysteresis thresholdingã€‚è¿Ÿæ»é˜ˆå€¼ï¼Œå¯¹å¼±åƒç´ è¿›ä¸€æ­¥åŒºåˆ†ï¼Œç¡®å®šæ˜¯è¾¹ç¼˜è¿˜æ˜¯å™ªå£°ã€‚
  1. æ¢¯åº¦å¤§äºmaxValçš„è¯æ˜¯è¾¹ç¼˜
  2. æ¢¯åº¦å°äºminValçš„è¯ä¸æ˜¯è¾¹ç¼˜ï¼Œå¹¶ä¸”æŠŠè¿™ä¸ªç‚¹åˆ é™¤ã€‚
  3. æ¢¯åº¦åœ¨[minVal, maxVal]ä¹‹é—´çš„ï¼Œåªæœ‰å’ŒmaxValç›¸è¿çš„åƒç´ æ‰æ˜¯è¾¹ç¼˜ã€‚

{% codeblock lang:python %}
def do_canny(frame):
    # Converts frame to grayscale because we only need the luminance channel for detecting edges - less computationally expensive
    gray = cv.cvtColor(frame, cv.COLOR_RGB2GRAY)
    # Applies a 5x5 gaussian blur with deviation of 0 to frame - not mandatory since Canny will do this for us
    blur = cv.GaussianBlur(gray, (5, 5), 0)
    # Applies Canny edge detector with minVal of 50 and maxVal of 150
    canny = cv.Canny(blur, 50, 150)
    return canny
{% endcodeblock %}

### ç”»å¤šè¾¹å½¢åŒºåŸŸ

{% codeblock lang:python %}
def do_segment(frame):
    # Since an image is a multi-directional array containing the relative intensities of each pixel in the image, we can use frame.shape to return a tuple: [number of rows, number of columns, number of channels] of the dimensions of the frame
    # frame.shape[0] give us the number of rows of pixels the frame has. Since height begins from 0 at the top, the y-coordinate of the bottom of the frame is its height
    height = frame.shape[0]
    # Creates a triangular polygon for the mask defined by three (x, y) coordinates
    polygons = np.array([
                            [(0, height), (800, height), (380, 290)]
                        ])
    # Creates an image filled with zero intensities with the same dimensions as the frame
    mask = np.zeros_like(frame)
    # é™¤äº†maskéƒ¨åˆ†å…¶ä»–éƒ½è®¾å®šä¸º255
    cv.fillPoly(mask, polygons, 255)
    # æŒ‰ä½ä¸
    segment = cv.bitwise_and(frame, mask)
    return segment
{% endcodeblock %}

### éœå¤«å˜æ¢

æŠŠå‚æ•°å’Œå˜é‡äº’æ¢ã€‚ä¸€æ¡ç›´çº¿å¯¹åº”éœå¤«ç©ºé—´çš„ä¸€ä¸ªç‚¹ã€‚
ç¬›å¡å°”ç©ºé—´çš„ç‚¹å°±æ˜¯éœå¤«ç©ºé—´çš„çº¿ã€‚
ç¬›å¡å°”ç©ºé—´çš„çº¿å°±æ˜¯éœå¤«ç©ºé—´çš„ç‚¹ã€‚

æ‹Ÿåˆç›´çº¿çš„æ–¹æ³•ï¼šå¯¹æ‰€æœ‰çš„ç¬›å¡å°”åæ ‡ç³»çš„ç‚¹æŠ•å½±åˆ°éœå¤«ç©ºé—´çš„å½“ä¸­ï¼Œçœ‹çœ‹ä»–ä»¬çš„äº¤ç‚¹çš„ä½ç½®ã€‚

ç‰¹æ®Šæƒ…å†µï¼šçº¿å‚ç›´ä¸åæ ‡è½´çš„æ—¶å€™ï¼Œæœ‰ä¸€ä¸ªå€¼æ˜¯æ— ç©·å¤§çš„ï¼Œæ— æ³•åœ¨éœå¤«ç©ºé—´å½“ä¸­è¡¨ç¤ºå‡ºæ¥ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œåœ¨ç¬›å¡å°”åæ ‡ç³»å½“ä¸­ä½¿ç”¨æåæ ‡æ¥è¡¨ç¤ºçº¿ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨ç›´çº¿çš„å‚æ•°æ–¹ç¨‹ï¼š

$$d = x \cos \theta + y \sin \theta $$

éœå¤«ç©ºé—´ç›¸äº¤çš„æ›²çº¿è¶Šå¤šï¼Œäº¤ç‚¹ä¹Ÿå°±è¶Šå¤šã€‚å®šä¹‰äº¤ç‚¹çš„æœ€å°é˜ˆå€¼æ¥æ£€æµ‹çº¿ã€‚å¦‚æœäº¤ç‚¹çš„æ•°é‡è¶…è¿‡äº†é˜ˆå€¼ï¼Œé‚£ä¹ˆå°±è¯´æ˜ç¡®å®šäº†å‚æ•°ä¸ºdå’Œthetaçš„ç›´çº¿ã€‚

{% codeblock lang:python %}
hough = cv.HoughLinesP(segment, 2, np.pi / 180, 100, np.array([]), minLineLength = 100, maxLineGap = 50)
{% endcodeblock %}

### ä¸¤å¼ å›¾å åŠ 

{% codeblock lang:python %}
    output = cv.addWeighted(frame, 0.9, lines_visualize, 1, 1)
{% endcodeblock %}